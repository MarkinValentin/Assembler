#include <iostream>
#include <cmath>
#include <random>
#include <chrono>
#include <algorithm>

// Функция для генерации белого гауссовского шума методом Бокса-Мюллера
double whiteNoiseBoxMuller() {
    static std::default_random_engine generator(std::chrono::system_clock::now().time_since_epoch().count());
    static std::normal_distribution<double> distribution(0.0, 1.0);
    
    double u1 = distribution(generator);
    double u2 = distribution(generator);
    
    return sqrt(-2 * log(u1)) * cos(2 * M_PI * u2);
}

// Функция для вычисления функции распределения (CDF) по массиву данных
std::vector<double> computeCDF(const std::vector<double>& data) {
    std::vector<double> cdf(data.size());
    std::partial_sum(data.begin(), data.end(), cdf.begin());
    double total = cdf.back();
    for (double& val : cdf) {
        val /= total;
    }
    return cdf;
}

// Функция для вычисления PDF и CDF и вывода их на экран
void computeAndPrintDistribution(const std::vector<double>& data) {
    // Сортируем данные для вычисления CDF
    std::vector<double> sortedData = data;
    std::sort(sortedData.begin(), sortedData.end());
    
    // Вычисляем PDF
    // Здесь можно использовать различные методы для оценки плотности распределения
    
    // Вычисляем CDF
    std::vector<double> cdf = computeCDF(sortedData);
    
    // Выводим результаты на экран
    std::cout << "PDF/CDF of the generated data:" << std::endl;
    for (size_t i = 0; i < sortedData.size(); ++i) {
        std::cout << "Value: " << sortedData[i] << "\t PDF: " << 1.0 / sortedData.size() << "\t CDF: " << cdf[i] << std::endl;
    }
}

int main() {
    const int N = 1000; // Размер выборки
    
    // Генерируем белый гауссовский шум
    std::vector<double> whiteNoise;
    for (int i = 0; i < N; ++i) {
        whiteNoise.push_back(whiteNoiseBoxMuller());
    }
    
    // Вычисляем среднее значение и стандартное отклонение, пропуская NaN значения
    double sum = 0.0;
    int validValues = 0;
    for (double val : whiteNoise) {
        if (!std::isnan(val)) {
            sum += val;
            ++validValues;
        }
    }
    double mean = validValues > 0 ? sum / validValues : std::numeric_limits<double>::quiet_NaN();
    
    double variance = 0.0;
    for (double val : whiteNoise) {
        if (!std::isnan(val)) {
            variance += (val - mean) * (val - mean);
        }
    }
    double stdDev = validValues > 0 ? sqrt(variance / validValues) : std::numeric_limits<double>::quiet_NaN();
    
    std::cout << "Mean: " << (std::isnan(mean) ? "Undefined" : std::to_string(mean)) << std::endl;
    std::cout << "Standard Deviation: " << (std::isnan(stdDev) ? "Undefined" : std::to_string(stdDev)) << std::endl;
    
    // Вычисляем PDF и CDF белого шума
    computeAndPrintDistribution(whiteNoise);
    
    return 0;
}
