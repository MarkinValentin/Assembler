#include <iostream>
#include <cmath>
#include <random>
#include <chrono>
#include <algorithm>

// Функция для генерации белого гауссовского шума методом Бокса-Мюллера
double whiteNoiseBoxMuller() {
    static std::default_random_engine generator(std::chrono::system_clock::now().time_since_epoch().count());
    static std::normal_distribution<double> distribution(0.0, 1.0);
    
    double u1 = distribution(generator);
    double u2 = distribution(generator);
    
    return sqrt(-2 * log(u1)) * cos(2 * M_PI * u2);
}

// Функция для вычисления функции распределения (CDF) по массиву данных
std::vector<double> computeCDF(const std::vector<double>& data) {
    std::vector<double> cdf(data.size());
    std::partial_sum(data.begin(), data.end(), cdf.begin());
    double total = cdf.back();
    for (double& val : cdf) {
        val /= total;
    }
    return cdf;
}

// Функция для вычисления PDF и CDF и вывода их на экран
void computeAndPrintDistribution(const std::vector<double>& data) {
    // Сортируем данные для вычисления CDF
    std::vector<double> sortedData = data;
    std::sort(sortedData.begin(), sortedData.end());
    
    // Вычисляем PDF
    // Здесь можно использовать различные методы для оценки плотности распределения
    
    // Вычисляем CDF
    std::vector<double> cdf = computeCDF(sortedData);
    
    // Выводим результаты на экран
    std::cout << "PDF/CDF of the generated data:" << std::endl;
    for (size_t i = 0; i < sortedData.size(); ++i) {
        std::cout << "Value: " << sortedData[i] << "\t PDF: " << 1.0 / sortedData.size() << "\t CDF: " << cdf[i] << std::endl;
    }
}

int main() {
    const int N = 1000; // Размер выборки
    
    // Генерируем белый гауссовский шум
    std::vector<double> whiteNoise;
    for (int i = 0; i < N; ++i) {
        whiteNoise.push_back(whiteNoiseBoxMuller());
    }
    
    // Выводим среднее значение и стандартное отклонение
    double sum = 0.0;
    for (double val : whiteNoise) {
        sum += val;
    }
    double mean = sum / N;
    
    double variance = 0.0;
    for (double val : whiteNoise) {
        variance += (val - mean) * (val - mean);
    }
    double stdDev = sqrt(variance / N);
    
    std::cout << "Mean: " << mean << std::endl;
    std::cout << "Standard Deviation: " << stdDev << std::endl;
    
    // Вычисляем PDF и CDF белого шума
    computeAndPrintDistribution(whiteNoise);
    
    // Теперь сравним сгенерированные данные с данными, сгенерированными стандартной функцией
    std::vector<double> standardNoise;
    std::default_random_engine generator(std::chrono::system_clock::now().time_since_epoch().count());
    std::normal_distribution<double> distribution(0.0, 1.0);
    for (int i = 0; i < N; ++i) {
        standardNoise.push_back(distribution(generator));
    }
    
    // Вычисляем PDF и CDF стандартного шума
    computeAndPrintDistribution(standardNoise);
    
    // Сравниваем распределения с помощью теста Колмогорова-Смирнова
    double ksStatistic = 0.0;
    for (size_t i = 0; i < N; ++i) {
        double diff = fabs(whiteNoise[i] - standardNoise[i]);
        if (diff > ksStatistic) {
            ksStatistic = diff;
        }
    }
    std::cout << "Kolmogorov-Smirnov Statistic: " << ksStatistic << std::endl;
    
    return 0;
}
