#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <semaphore.h>
#include <string.h>
#include <ctype.h>

#define READ_END 0
#define WRITE_END 1

int print_help()
{
    printf("\nUsage: ./main <path> <N> <mode>\n");
    printf("\tpath — file to read \n");
    printf("\tN — fork number \n");
    printf("\tmode - shm or pipe \n");
    return 1;
}

int catch_error()
{
    perror("\nError");
    print_help();
}

int is_positive_integer(const char *str)
{
    for (size_t i = 0; i < strlen(str); ++i)
    {
    	if (!isdigit(str[i]))
    	{
    	    return 0; // Not a digit
    	}
    }
    return 1; // All characters are digits
}

int main(int argc, char **argv) {
    if (argc != 4) {
    	return print_help();
    }
    
    char *input_path = argv[1];
    int nChildren = atoi(argv[2]);
    
    if (!is_positive_integer(argv[2]))
    {
    	printf("Second argument must be a positive integer!", 43);
    	return print_help();
    }
    
    printf("Path to file: %s \n", input_path);
    printf("Fork number: %d \n", nChildren);
    
 	
    FILE *file = fopen(input_path, "r");
    if (!file) {
        catch_error();
    }   
	
    
    int *numbers = malloc(sizeof(int));
    if (numbers == NULL) {
    	printf("Error: Memory allocation failed\n");
        catch_error();
    }
    
    int count = 0, num, capacity = 1;
    while (fscanf(file, "%d", &num) == 1) {
        if (count >= capacity) {
            capacity *= 2;
            numbers = realloc(numbers, capacity * sizeof(int));
            if (numbers == NULL) {
                fprintf(stderr, "Memory reallocation failed\n");
                fclose(file);
                exit(EXIT_FAILURE);
            }
        }
        numbers[count++] = num;
    }
    fclose(file);

    if (count < 2) {
        printf("Too few numbers (count must be greater than 2) \n");
        free(numbers);
        return print_help();
    }

    if (nChildren > count / 2) {
        nChildren = count / 2;
        printf("Too many forks. New fork number: %d \n", nChildren);
    }
    
    int n = count / nChildren;
    int n_last = n + count % nChildren;

    printf("Each proc gets: %d numbers \n", n);
    printf("Last proc gets: %d numbers \n", n_last);

    if (strcmp(argv[3], "shm") == 0) {
    	printf("Current mode is shared memory\n");
        SharedMemory(numbers, count, nChildren);
    } else if (strcmp(argv[3], "pipe") == 0) {
    	printf("Current mode is pipes\n");
        Pipes(numbers, count, nChildren);
    } else {
        printf("Error: Bad IPC mode.\n");
        free(numbers);
        return print_help();
    }

    free(numbers);
    return 0;
}


void SharedMemory(int *numbers, int count, int nChildren) {
    int shmID = shmget(IPC_PRIVATE, count * sizeof(int), IPC_CREAT | 0666);
    if (shmID == -1) {
    	printf("Error: shmget failed\n");
        catch_error();
    }

    int *shmPtr = (int *)shmat(shmID, NULL, 0);
    if (shmPtr == (void *)-1) {
   	printf("Error: shmat failed\n");
        // Очистка созданного сегмента разделяемой памяти, если shmat не удался
        shmctl(shmID, IPC_RMID, NULL);
        catch_error();
    }
    memcpy(shmPtr, numbers, count * sizeof(int));

    int shmIDResult = shmget(IPC_PRIVATE, nChildren * sizeof(long), IPC_CREAT | 0666);
    if (shmIDResult == -1) {
    	printf("Error: shmget failed for result\n");
        // Освобождение ресурсов и выход при ошибке
        shmdt(shmPtr); // Отсоединение shmPtr
        shmctl(shmID, IPC_RMID, NULL); // Удаление shmID
        catch_error();
    }

    long *resultPtr = (long *)shmat(shmIDResult, NULL, 0);
    if (resultPtr == (void *)-1) {
        perror("shmat failed for result");
        // Освобождение ресурсов и выход при ошибке
        shmdt(shmPtr); // Отсоединение shmPtr
        shmctl(shmID, IPC_RMID, NULL); // Удаление shmID
        shmctl(shmIDResult, IPC_RMID, NULL); // Удаление shmIDResult
        catch_error();
    }

    // Удаление семафора перед созданием для избежания ошибки повторного создания
    sem_unlink("/semaphore");
    sem_t *sem = sem_open("/semaphore", O_CREAT | O_EXCL, 0666, 1);
    if (sem == SEM_FAILED) {
        perror("sem_open failed");
        // Освобождение ресурсов и выход при ошибке
        shmdt(shmPtr); // Отсоединение shmPtr
        shmdt(resultPtr); // Отсоединение resultPtr
        shmctl(shmID, IPC_RMID, NULL); // Удаление shmID
        shmctl(shmIDResult, IPC_RMID, NULL); // Удаление shmIDResult
        catch_error();
    }

    for (int i = 0; i < nChildren; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            char shmIDStr[20], shmIDResultStr[20], childIndexStr[20], nChildrenStr[20], countStr[20];
            sprintf(shmIDStr, "%d", shmID);
            sprintf(shmIDResultStr, "%d", shmIDResult);
            sprintf(childIndexStr, "%d", i);
            sprintf(nChildrenStr, "%d", nChildren);
            sprintf(countStr, "%d", count);
            execl("./child", "child", "shm", shmIDStr, shmIDResultStr, childIndexStr, nChildrenStr, countStr, (char *)NULL);
            printf("Error: execl failed\n");
            catch_error();
        }
    }

    for (int i = 0; i < nChildren; i++) {
        wait(NULL); // Ожидание завершения всех дочерних процессов
    }

    long totalSum = 0;
    for (int i = 0; i < nChildren; i++) {
        totalSum += resultPtr[i]; // Суммирование результатов работы дочерних процессов
    }
    printf("Total sum of squares: %ld\n", totalSum);

    // Освобождение ресурсов перед выходом из функции
    shmdt(shmPtr);
    shmdt(resultPtr);
    shmctl(shmID, IPC_RMID, NULL);
    shmctl(shmIDResult, IPC_RMID, NULL);
    sem_close(sem);
    sem_unlink("/semaphore");
}



void Pipes(int *numbers, int count, int nChildren) {

    int segmentSize = count / nChildren;
    int remainder = count % nChildren;
    long totalSum = 0; // Для хранения общей суммы

    int **pipes = malloc(nChildren * sizeof(int*));
    int **resultPipes = malloc(nChildren * sizeof(int*));
    for (int i = 0; i < nChildren; i++) {
        pipes[i] = malloc(2 * sizeof(int));
        resultPipes[i] = malloc(2 * sizeof(int));

        if (pipe(pipes[i]) != 0 || pipe(resultPipes[i]) != 0) {
            printf("Error: pipe failed\n");
            // Освобождение ресурсов перед выходом из-за ошибки
            for (int j = 0; j <= i; j++) {
                free(pipes[j]);
                free(resultPipes[j]);
            }
            free(pipes);
            free(resultPipes);
            catch_error();
        }
    }

    for (int i = 0; i < nChildren; i++) {
        pid_t pid = fork();
        if (pid == 0) { // Child process
            // Закрытие всех каналов, кроме используемых текущим процессом
            for (int j = 0; j < nChildren; j++) {
                if (j != i) {
                    close(pipes[j][READ_END]);
                    close(pipes[j][WRITE_END]);
                    close(resultPipes[j][READ_END]);
                    close(resultPipes[j][WRITE_END]);
                }
            }

            close(pipes[i][WRITE_END]);
            close(resultPipes[i][READ_END]);

            dup2(pipes[i][READ_END], STDIN_FILENO);
            dup2(resultPipes[i][WRITE_END], STDOUT_FILENO);

            close(pipes[i][READ_END]);
            close(resultPipes[i][WRITE_END]);

            char childIndexStr[10];
            sprintf(childIndexStr, "%d", i);
            execl("./child", "child", "pipe", childIndexStr, (char *)NULL);
            perror("execl failed");
            exit(EXIT_FAILURE);
        }
        // Parent process continues
    }

    // В родительском процессе - закрыть неиспользуемые концы каналов
    for (int i = 0; i < nChildren; i++) {

        close(pipes[i][READ_END]);
        close(resultPipes[i][WRITE_END]);
       
        int start = i * segmentSize + (i < remainder ? i : remainder);
        int end = start + segmentSize + (i < remainder ? 1 : 0);
        for (int j = start; j < end; j++) {
            if (write(pipes[i][WRITE_END], &numbers[j], sizeof(numbers[j])) == -1) {
            	printf("Error: write to pipe failed\n");
                // Освобождение ресурсов и завершение программы из-за ошибки
                catch_error();
            }
        }
        close(pipes[i][WRITE_END]);
    }

    // Сбор результатов от дочерних процессов
    for (int i = 0; i < nChildren; i++) {
        long result;
        if (read(resultPipes[i][READ_END], &result, sizeof(result)) == -1) {
            printf("Error: read from pipe failed\n");
            // Продолжить, чтобы закрыть все открытые каналы
        }
        totalSum += result;
        close(resultPipes[i][READ_END]);
    }

    for (int i = 0; i < nChildren; i++) {
        wait(NULL);
    }

    printf("Total sum of squares: %ld\n", totalSum); // Выводим общую сумму

    // Освобождение выделенной памяти
    for (int i = 0; i < nChildren; i++) {
        free(pipes[i]);
        free(resultPipes[i]);
    }
    free(pipes);
    free(resultPipes);
}
